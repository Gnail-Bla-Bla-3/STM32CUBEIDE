/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "UART_RM25.h"
#include "DBUS.h"
#include <math.h>
// #include "CC_Handler.h"
#include "CAN.h"
#include "CAL_RM25.h"

#include "BMI088driver.h"
#include "BMI088Middleware.h"
#include "BMI088reg.h"
#include "custom_math.h"
#include "pwm.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
int16_t turretRotationForCV[3] = {0, 0, 0};
uint8_t SENTRYSHOOT[2] = {0, 0};
uint8_t currentGameStatus = 0;
int16_t sentryAutoState = 0;
uint8_t driveChassisForwards = 0;
int16_t turretCVAimingSum = 0;
int32_t SentryTurnAngle = 0;
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
CAN_HandleTypeDef hcan1;
CAN_HandleTypeDef hcan2;

I2C_HandleTypeDef hi2c3;

SPI_HandleTypeDef hspi1;

TIM_HandleTypeDef htim1;
TIM_HandleTypeDef htim4;
TIM_HandleTypeDef htim5;
TIM_HandleTypeDef htim8;
TIM_HandleTypeDef htim10;

UART_HandleTypeDef huart1;
UART_HandleTypeDef huart3;
UART_HandleTypeDef huart6;
DMA_HandleTypeDef hdma_usart1_rx;
DMA_HandleTypeDef hdma_usart3_rx;
DMA_HandleTypeDef hdma_usart6_rx;

/* Definitions for FlowManager */
osThreadId_t FlowManagerHandle;
const osThreadAttr_t FlowManager_attributes = {
  .name = "FlowManager",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityHigh,
};
/* Definitions for IMUtempPIDtask */
osThreadId_t IMUtempPIDtaskHandle;
const osThreadAttr_t IMUtempPIDtask_attributes = {
  .name = "IMUtempPIDtask",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for TurretTask */
osThreadId_t TurretTaskHandle;
const osThreadAttr_t TurretTask_attributes = {
  .name = "TurretTask",
  .stack_size = 1024 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for SentryAutonomy */
osThreadId_t SentryAutonomyHandle;
const osThreadAttr_t SentryAutonomy_attributes = {
  .name = "SentryAutonomy",
  .stack_size = 512 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_CAN1_Init(void);
static void MX_CAN2_Init(void);
static void MX_SPI1_Init(void);
static void MX_TIM4_Init(void);
static void MX_USART1_UART_Init(void);
static void MX_USART6_UART_Init(void);
static void MX_TIM1_Init(void);
static void MX_TIM8_Init(void);
static void MX_USART3_UART_Init(void);
static void MX_TIM10_Init(void);
static void MX_I2C3_Init(void);
static void MX_TIM5_Init(void);
void StartFlowManager(void *argument);
void imu_temp_control_task(void *argument);
void StartTurretTask(void *argument);
void StartSentryAutonomy(void *argument);

/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_CAN1_Init();
  MX_CAN2_Init();
  MX_SPI1_Init();
  MX_TIM4_Init();
  // MX_USART1_UART_Init();
  MX_USART6_UART_Init();
  MX_TIM1_Init();
  MX_TIM8_Init();
  MX_USART3_UART_Init();
  MX_TIM10_Init();
  MX_I2C3_Init();
  MX_TIM5_Init();
  /* USER CODE BEGIN 2 */
  PWMInit(&htim1, &htim4, &htim5, &htim8);

  /* USER CODE END 2 */

  /* Init scheduler */
  osKernelInitialize();

  /* USER CODE BEGIN RTOS_MUTEX */
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
  /* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
  /* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* creation of FlowManager */
  FlowManagerHandle = osThreadNew(StartFlowManager, NULL, &FlowManager_attributes);

  /* creation of IMUtempPIDtask */
  IMUtempPIDtaskHandle = osThreadNew(imu_temp_control_task, NULL, &IMUtempPIDtask_attributes);

  /* creation of TurretTask */
  TurretTaskHandle = osThreadNew(StartTurretTask, NULL, &TurretTask_attributes);

  /* creation of SentryAutonomy */
  SentryAutonomyHandle = osThreadNew(StartSentryAutonomy, NULL, &SentryAutonomy_attributes);

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

  /* USER CODE BEGIN RTOS_EVENTS */
  /* add events, ... */
  /* USER CODE END RTOS_EVENTS */

  /* Start scheduler */
  osKernelStart();

  /* We should never get here as control is now taken by the scheduler */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 6;
  RCC_OscInitStruct.PLL.PLLN = 168;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
  {
    Error_Handler();
  }

  /** Enables the Clock Security System
  */
  HAL_RCC_EnableCSS();
}

/**
  * @brief CAN1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_CAN1_Init(void)
{

  /* USER CODE BEGIN CAN1_Init 0 */

  /* USER CODE END CAN1_Init 0 */

  /* USER CODE BEGIN CAN1_Init 1 */

  /* USER CODE END CAN1_Init 1 */
  hcan1.Instance = CAN1;
  hcan1.Init.Prescaler = 3;
  hcan1.Init.Mode = CAN_MODE_NORMAL;
  hcan1.Init.SyncJumpWidth = CAN_SJW_1TQ;
  hcan1.Init.TimeSeg1 = CAN_BS1_10TQ;
  hcan1.Init.TimeSeg2 = CAN_BS2_3TQ;
  hcan1.Init.TimeTriggeredMode = DISABLE;
  hcan1.Init.AutoBusOff = DISABLE;
  hcan1.Init.AutoWakeUp = DISABLE;
  hcan1.Init.AutoRetransmission = DISABLE;
  hcan1.Init.ReceiveFifoLocked = DISABLE;
  hcan1.Init.TransmitFifoPriority = DISABLE;
  if (HAL_CAN_Init(&hcan1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN CAN1_Init 2 */

  /* USER CODE END CAN1_Init 2 */

}

/**
  * @brief CAN2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_CAN2_Init(void)
{

  /* USER CODE BEGIN CAN2_Init 0 */

  /* USER CODE END CAN2_Init 0 */

  /* USER CODE BEGIN CAN2_Init 1 */

  /* USER CODE END CAN2_Init 1 */
  hcan2.Instance = CAN2;
  hcan2.Init.Prescaler = 3;
  hcan2.Init.Mode = CAN_MODE_NORMAL;
  hcan2.Init.SyncJumpWidth = CAN_SJW_1TQ;
  hcan2.Init.TimeSeg1 = CAN_BS1_10TQ;
  hcan2.Init.TimeSeg2 = CAN_BS2_3TQ;
  hcan2.Init.TimeTriggeredMode = DISABLE;
  hcan2.Init.AutoBusOff = DISABLE;
  hcan2.Init.AutoWakeUp = DISABLE;
  hcan2.Init.AutoRetransmission = DISABLE;
  hcan2.Init.ReceiveFifoLocked = DISABLE;
  hcan2.Init.TransmitFifoPriority = DISABLE;
  if (HAL_CAN_Init(&hcan2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN CAN2_Init 2 */

  /* USER CODE END CAN2_Init 2 */

}

/**
  * @brief I2C3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C3_Init(void)
{

  /* USER CODE BEGIN I2C3_Init 0 */

  /* USER CODE END I2C3_Init 0 */

  /* USER CODE BEGIN I2C3_Init 1 */

  /* USER CODE END I2C3_Init 1 */
  hi2c3.Instance = I2C3;
  hi2c3.Init.ClockSpeed = 400000;
  hi2c3.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c3.Init.OwnAddress1 = 0;
  hi2c3.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c3.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c3.Init.OwnAddress2 = 0;
  hi2c3.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c3.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C3_Init 2 */

  /* USER CODE END I2C3_Init 2 */

}

/**
  * @brief SPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI1_Init(void)
{

  /* USER CODE BEGIN SPI1_Init 0 */

  /* USER CODE END SPI1_Init 0 */

  /* USER CODE BEGIN SPI1_Init 1 */

  /* USER CODE END SPI1_Init 1 */
  /* SPI1 parameter configuration*/
  hspi1.Instance = SPI1;
  hspi1.Init.Mode = SPI_MODE_MASTER;
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;
  hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;
  hspi1.Init.NSS = SPI_NSS_SOFT;
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi1.Init.CRCPolynomial = 10;
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI1_Init 2 */

  /* USER CODE END SPI1_Init 2 */

}

/**
  * @brief TIM1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM1_Init(void)
{

  /* USER CODE BEGIN TIM1_Init 0 */

  /* USER CODE END TIM1_Init 0 */

  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};

  /* USER CODE BEGIN TIM1_Init 1 */

  /* USER CODE END TIM1_Init 1 */
  htim1.Instance = TIM1;
  htim1.Init.Prescaler = 83;
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim1.Init.Period = 19999;
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim1.Init.RepetitionCounter = 0;
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
  {
    Error_Handler();
  }
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
  sBreakDeadTimeConfig.DeadTime = 0;
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM1_Init 2 */

  /* USER CODE END TIM1_Init 2 */
  HAL_TIM_MspPostInit(&htim1);

}

/**
  * @brief TIM4 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM4_Init(void)
{

  /* USER CODE BEGIN TIM4_Init 0 */

  /* USER CODE END TIM4_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM4_Init 1 */

  /* USER CODE END TIM4_Init 1 */
  htim4.Instance = TIM4;
  htim4.Init.Prescaler = 0;
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim4.Init.Period = 20999;
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim4) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 10499;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM4_Init 2 */

  /* USER CODE END TIM4_Init 2 */
  HAL_TIM_MspPostInit(&htim4);

}

/**
  * @brief TIM5 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM5_Init(void)
{

  /* USER CODE BEGIN TIM5_Init 0 */

  /* USER CODE END TIM5_Init 0 */

  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM5_Init 1 */

  /* USER CODE END TIM5_Init 1 */
  htim5.Instance = TIM5;
  htim5.Init.Prescaler = 42;
  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim5.Init.Period = 19999;
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_PWM_Init(&htim5) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM5_Init 2 */

  /* USER CODE END TIM5_Init 2 */
  HAL_TIM_MspPostInit(&htim5);

}

/**
  * @brief TIM8 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM8_Init(void)
{

  /* USER CODE BEGIN TIM8_Init 0 */

  /* USER CODE END TIM8_Init 0 */

  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};

  /* USER CODE BEGIN TIM8_Init 1 */

  /* USER CODE END TIM8_Init 1 */
  htim8.Instance = TIM8;
  htim8.Init.Prescaler = 83;
  htim8.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim8.Init.Period = 19999;
  htim8.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim8.Init.RepetitionCounter = 0;
  htim8.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
  if (HAL_TIM_PWM_Init(&htim8) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
  if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim8, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
  {
    Error_Handler();
  }
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
  sBreakDeadTimeConfig.DeadTime = 0;
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim8, &sBreakDeadTimeConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM8_Init 2 */

  /* USER CODE END TIM8_Init 2 */
  HAL_TIM_MspPostInit(&htim8);

}

/**
  * @brief TIM10 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM10_Init(void)
{

  /* USER CODE BEGIN TIM10_Init 0 */

  /* USER CODE END TIM10_Init 0 */

  TIM_OC_InitTypeDef sConfigOC = {0};

  /* USER CODE BEGIN TIM10_Init 1 */

  /* USER CODE END TIM10_Init 1 */
  htim10.Instance = TIM10;
  htim10.Init.Prescaler = 0;
  htim10.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim10.Init.Period = 4999;
  htim10.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim10.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim10) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_TIM_PWM_Init(&htim10) != HAL_OK)
  {
    Error_Handler();
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim10, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM10_Init 2 */

  /* USER CODE END TIM10_Init 2 */
  HAL_TIM_MspPostInit(&htim10);

}

/**
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{

  /* USER CODE BEGIN USART1_Init 0 */

  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 115200;
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}

/**
  * @brief USART3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART3_UART_Init(void)
{

  /* USER CODE BEGIN USART3_Init 0 */

  /* USER CODE END USART3_Init 0 */

  /* USER CODE BEGIN USART3_Init 1 */

  /* USER CODE END USART3_Init 1 */
  huart3.Instance = USART3;
  huart3.Init.BaudRate = 100000;
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_EVEN;
  huart3.Init.Mode = UART_MODE_TX_RX;
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART3_Init 2 */

  /* USER CODE END USART3_Init 2 */

}

/**
  * @brief USART6 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART6_UART_Init(void)
{

  /* USER CODE BEGIN USART6_Init 0 */

  /* USER CODE END USART6_Init 0 */

  /* USER CODE BEGIN USART6_Init 1 */

  /* USER CODE END USART6_Init 1 */
  huart6.Instance = USART6;
  huart6.Init.BaudRate = 115200;
  huart6.Init.WordLength = UART_WORDLENGTH_8B;
  huart6.Init.StopBits = UART_STOPBITS_1;
  huart6.Init.Parity = UART_PARITY_NONE;
  huart6.Init.Mode = UART_MODE_TX_RX;
  huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart6.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart6) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART6_Init 2 */

  /* USER CODE END USART6_Init 2 */

}

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
  __HAL_RCC_DMA2_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
  /* DMA2_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream1_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA2_Stream1_IRQn);
  /* DMA2_Stream2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOG_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOI_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOF_CLK_ENABLE();
  __HAL_RCC_GPIOE_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);

  /*Configure GPIO pin : PG6 */
  GPIO_InitStruct.Pin = GPIO_PIN_6;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);

  /*Configure GPIO pin : PG3 */
  GPIO_InitStruct.Pin = GPIO_PIN_3;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);

  /*Configure GPIO pin : PA0 */
  GPIO_InitStruct.Pin = GPIO_PIN_0;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*Configure GPIO pin : PA4 */
  GPIO_InitStruct.Pin = GPIO_PIN_4;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*Configure GPIO pins : INT1_ACCEL_Pin_Pin INT1_GRYO_Pin_Pin */
  GPIO_InitStruct.Pin = INT1_ACCEL_Pin_Pin|INT1_GRYO_Pin_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pin : PB0 */
  GPIO_InitStruct.Pin = GPIO_PIN_0;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI3_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(EXTI3_IRQn);

  HAL_NVIC_SetPriority(EXTI4_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(EXTI4_IRQn);

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

void fondlerAutoReverse (int8_t allVars[5], int8_t RCSwitch, int8_t M2006IDX, int8_t reverseRotation, PID_preset_t indexerPreset) {
	int16_t flywheelSpeed = getMotorRPM(Bus1, M3508, 1);
    if ((/*(pc_control.left_button_down == 1) && */(flywheelSpeed > 7000) && (allVars[4] == 0)) || (RCSwitch == 1)) {
    	// setMotorRPM(Bus2, M2006, 6, (100), indexerPreset);
    	allVars[0] = 1;

		if (allVars[3] > 0 && allVars[2] == 0) {
			setMotorRPM(Bus1, M2006, M2006IDX, reverseRotation*15000, indexerPreset);
			allVars[3]--;
		} else {
			allVars[2] = 0;
			// usart_printf("BeansOutput1\r\n");
			setMotorRPM(Bus1, M2006, M2006IDX, -270*16*reverseRotation, indexerPreset);
			if (reverseRotation == 1) {
				if (allVars[1] == 0 && getMotorRPM(Bus1, M2006, M2006IDX) <= -10) {
					allVars[1] = 1;
				} else if (getMotorRPM(Bus1, M2006, M2006IDX) > -1 && allVars[1] == 1) {         // jammed
					allVars[3] = 12;
					allVars[1] = 0;
				}
			} else {
				if (allVars[1] == 0 && getMotorRPM(Bus1, M2006, M2006IDX) >= 10) {
					allVars[1] = 1;
				} else if (getMotorRPM(Bus1, M2006, M2006IDX) < 1 && allVars[1] == 1) {         // jammed
					allVars[3] = 12;
					allVars[1] = 0;
				}
			}
		}
    } else {
    	allVars[0] = 0;
    	allVars[2] = 1;
    	allVars[1] = 0;
    	setMotorRPM(Bus1, M2006, M2006IDX, 0, indexerPreset);
    }
}

float distanceCalc(int16_t height) {
	float distances[4] = {80.0, 41.0, 29.0, 25.0};
	if (height < 80 && height >= 41) {
		return (1/(distances[1] - distances[0]))*((float)(height)) + (1-(distances[0]/(distances[1] - distances[0])));
	} else if (height < 41 && height >= 29) {
		return (1/(distances[2] - distances[1]))*((float)(height)) + (2-(distances[1]/(distances[2] - distances[1])));
	} else if (height < 29 && height >= 25) {
		return (1/(distances[3] - distances[2]))*((float)(height)) + (3-(distances[2]/(distances[3] - distances[2])));
	} else {
		return 0;
	}
}


void rotationMatrix(uint8_t rotationType, float APC[3], float rotationAngle) {
	float NewAPC[3] = {0, 0, 0};
	switch (rotationType) {
	case 0: {
		NewAPC[0] = APC[0];
		NewAPC[1] = APC[1]*cosf(rotationAngle) - APC[2]*sinf(rotationAngle);
		NewAPC[2] = APC[1]*sinf(rotationAngle) + APC[2]*cosf(rotationAngle);
		break;
	}
	case 1: {
		NewAPC[0] = APC[0]*cosf(rotationAngle) + APC[2]*sinf(rotationAngle);
		NewAPC[1] = APC[1];
		NewAPC[2] = -1*APC[0]*sinf(rotationAngle) + APC[2]*cosf(rotationAngle);
		break;
	}
	case 2: {
		NewAPC[0] = APC[0]*cosf(rotationAngle) - APC[1]*sinf(rotationAngle);
		NewAPC[1] = APC[0]*sinf(rotationAngle) + APC[1]*cosf(rotationAngle);
		NewAPC[2] = APC[2];
		break;
	}
	}
	for (uint8_t i = 0; i < 3; i++) {
		APC[i] = NewAPC[i];
	}
}

void AngletoCoordinateCalculator(int16_t CVInfo[5], float turretRelativeRotation, int16_t turretPitch, int16_t enemyRelativeCoords[4][3]) {
	int16_t xVALRATIO = 338;
	int16_t yVALRATIO = 200; // CHANGE THIS

	/*
	 * This will be in METERS
	 * 	Index 0: X
	 * 	Index 1: Y
	 * 	Index 2: Distance (Z)
	 */
	float changeOfBasis[3] = {0, 0, 0};

	float armourPlateCoordinate[3] = {0, 0, 0};

	// Calculates the "Distance" from the armour plate relative to the camera position
	armourPlateCoordinate[2] = distanceCalc(CVInfo[3]);

	// Calculates the X and Y coordinates relative to the camera with the Distance and TAN(ARCTAN()) which cancels out
	armourPlateCoordinate[0] = ((CVInfo[0]*armourPlateCoordinate[2])/xVALRATIO);
	armourPlateCoordinate[1] = ((CVInfo[0]*armourPlateCoordinate[2])/yVALRATIO);

	// Fake change of basis to make it relative to the center of the barrels in the center of the turret
	armourPlateCoordinate[0] = armourPlateCoordinate[0] - changeOfBasis[0];
	armourPlateCoordinate[1] = armourPlateCoordinate[1] - changeOfBasis[1];
	armourPlateCoordinate[2] = armourPlateCoordinate[2] - changeOfBasis[2];

	armourPlateCoordinate[2] = -1*armourPlateCoordinate[2];
	rotationMatrix(1, armourPlateCoordinate, (turretRelativeRotation*2*M_PI)/360);
	rotationMatrix(0, armourPlateCoordinate, ((turretPitch*2*M_PI)/8191)-4100);


	for (int8_t i = 1; i > -1; i--) {
		for (uint8_t j = 0; j < 4; j++) {
			enemyRelativeCoords[j][i] = enemyRelativeCoords[j][i+1];
		}
	}

	for (int8_t i = 0; i < 3; i++) {
		enemyRelativeCoords[i][0] = armourPlateCoordinate[i];
	}
	enemyRelativeCoords[3][0] = 1;
}

/*
 * CVInfo:	Index 0: Bounding Box X
 * 			Index 1: Bounding Box Y
 * 			Index 2: Bounding Box Width
 * 			Index 3: Bounding Box Height
 * 			Index 4: Bounding Box Time Out
 *
 * enemyRelativeCoords:	Index 0, 0: Relative X Value	Index 0, 1: Old Relative X Value	Index 0, 2: Oldest Relative X Value
 * 						Index 1, 0: Relative Y Value	Index 1, 1: Old Relative Y Value	Index 1, 2: Oldest Relative Y Value
 * 						Index 2, 0: Relative Z Value	Index 2, 1: Old Relative Z Value	Index 2, 2: Oldest Relative Z Value
 * 						Index 3, 0: Not Null Value		Index 3, 1: Not Null Value			Index 3, 2: Not Null Value
 * 			NOTE: Values in here are in millimeters
 */
void leadCalculator (float currentAngle, int16_t CVInfo[5], int16_t enemyRelativeCoords[4][3]) {


}

// int16_t brans = (1/(distances[1] - distances[0]))*height + (1-(distances[0]/(distances[1] - distances[0])));
uint8_t WithinRangeCalculator(int16_t inputValue, int16_t searchPosition, int16_t delta) {
	if ((inputValue < searchPosition + delta) && (inputValue > searchPosition - delta)) {
		return 1;
	} else {
		return 0;
	}
}



/* USER CODE END 4 */

/* USER CODE BEGIN Header_StartFlowManager */
/**
  * @brief  Function implementing the FlowManager thread.
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartFlowManager */
void StartFlowManager(void *argument)
{
  /* USER CODE BEGIN 5 */
	uint8_t iCount = 0;
	int16_t forwardStrafe = 0;

	DBUS_Rx_Init(&huart3);

	// UART_Ex_Init(&huart1);
	UART_Ex_Init(&huart6);
	CAN_Init();
	BMI088_gyro_init();
  /* Infinite loop */
  for(;;)
  {
	  DBUS_Update();
	  // CAN_Updater(Bus1);
	  if(iCount%3==0){
		  CAL_Update();
	  }

	  if (driveChassisForwards == 1) {
		  forwardStrafe = 100;
	  } else {
		  forwardStrafe = 0;
	  }

	  // 930
	  CAL_SendChassisCommands(CAL_getCH1() + forwardStrafe,(CAL_getCH0()),CAL_getCH4(),((2750+500)/2),0,1,2);


	  //UART_Printf(&huart6,"DBUS Check: %d %d \n", getDR16_W(),getCC_W());
	  //UART_Printfmt(&huart6,"%d \n",getDR16_CH1());

	  if(iCount<255){
		  iCount++;
	  }else{
		  iCount = 0;
	  }
	  osDelay(1);
  }
  /* USER CODE END 5 */
}

/* USER CODE BEGIN Header_imu_temp_control_task */
/**
* @brief Function implementing the IMUtempPIDtask thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_imu_temp_control_task */
__weak void imu_temp_control_task(void *argument)
{
  /* USER CODE BEGIN imu_temp_control_task */
  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
  }
  /* USER CODE END imu_temp_control_task */
}

/* USER CODE BEGIN Header_StartTurretTask */
/**
* @brief Function implementing the TurretTask thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartTurretTask */
void StartTurretTask(void *argument)
{
  /* USER CODE BEGIN StartTurretTask */
	PID_preset_t turretRotation = {110.0, 0.0, 15.0};
	PID_preset_t turretPitch = {25.0, 0.0, 130.0};
	PID_preset_t test2 = {100.0, 0.01, 20.0};
	PID_preset_t test3 = {160.0, 0.0, 100.0};
	PID_preset_t fondler = {1.5, 0.0, 0.0};
	PID_preset_t flywheels = {4.0, 0.0, 0.0};

	float gyroidValue = 0;

	float targetTurretAng = 0;
	float currentTurretAng = 0;




	int16_t turretPitchPos = 4100;
	int8_t fondlerVars[2][5] = {{0, 0, 0, 0, 0}, {0, 0, 0, 0, 0}};
	uint8_t barrelToggle = 0;
	uint16_t speed = 5000;
	int16_t previousPeans = 0;

	int32_t toGoVelue = 0;

	int16_t turretYawVal = 0;
	// X, Y, Width, Height, TimeoutLength


  /* Infinite loop */
  for(;;)
  {


	  // Turret Pitch
	  // int16_t turretPitchVal = (1.4*(CAL_getCH3()))+4100;
	  // setMotorPosition(Bus2, GM6020, 3,  turretPitchVal, TurretRotation);

	  turretPitchPos = turretPitchPos + ((CAL_getCH3()+turretRotationForCV[1])*0.15);

	  // Minimum = 3200

	  if (sentryAutoState == 0) {
		  turretPitchPos = turretPitchPos + ((CAL_getCH3()+turretRotationForCV[1])*0.15);
	  } else if ((sentryAutoState != 0) || (sentryAutoState != 4)) {
		  turretPitchPos = 4100;
	  } else if (sentryAutoState == 4) {
		  turretPitchPos = turretRotationForCV[1];
	  }


	  // Minimum = 3200
	  if (turretPitchPos > 5000) {
		  turretPitchPos = 5000;
	  } else if (turretPitchPos < 4000) {
		  turretPitchPos = 4000;
	  }

	  setMotorPosition(Bus2, GM6020, 3,  turretPitchPos, turretPitch);
	  // UART_Printf(&huart6, "%d, %d\r\n", getRotorPosition(Bus2, GM6020, 3), turretPitchPos);




	  // float gyroVel[3] = {IMU_get_gyro(0), IMU_get_gyro(1), IMU_get_gyro(2)};


	  /*
	  float kP = 80.0;
	  // Tuned to KD of 125
	  float kD = 80.0;


	  float gyroVel2 = IMU_get_gyro(2);
	  if (gyroVel2 < 0.05 || gyroVel2 > -0.05) {
		  gyroVel2 = 0;
	  }

	  // Turret Rotation Debug Mode
	  if (sentryAutoState == 0) {
	  	   turretYawVal = CAL_getCH2();
	  	   // setMotorRPM(Bus1, GM6020, 5, (int16_t)(-0.4*(float)(turretYawVal)), test2);
	  } else if ((sentryAutoState != 0) || (sentryAutoState != 4)) {
		  // 2811
		   turretYawVal = 2811+910-400;
		   setMotorPosition(Bus1, GM6020, 5, turretYawVal, test3);
	  } else if (sentryAutoState == 4) {
		  setMotorPosition(Bus1, GM6020, 5, turretRotationForCV[0], test3);
	  }

	  turretYawVal = 2811+910-400 + CAL_getCH2();


	  int32_t toGoVelue = 2243 + CAL_getCH2();

	  int32_t beans = kP*(toGoVelue - getRotorPosition(Bus1, GM6020, 5)) + kD*(((toGoVelue - getRotorPosition(Bus1, GM6020, 5)) - previousPeans) + -80*gyroVel2);
	  previousPeans = (toGoVelue - getRotorPosition(Bus1, GM6020, 5));

	  int32_t beans2 = applyCtrlLimit(GM6020, beans);
	  CAN_setMotorCtrlVal(Bus1, GM6020, 5, beans2);
	  // setMotorPosition(Bus1, GM6020, 5, turretYawVal, test3);
	  // 2811
	  // 6607
	  UART_Printf(&huart6, "%d\r\n", getRotorPosition(Bus1, GM6020, 5));
	  */
	  float kP = 50.0;
	  // Tuned to KD of 125
	  float kD = 80.0;
	  float gyroVel2 = IMU_get_gyro(2);
	  if (gyroVel2 < 0.05 || gyroVel2 > -0.05) {
		  gyroVel2 = 0;
	  }
	  // Turret Rotation Debug Mode
	  // SentryTurnAngle
	  // turretYawVal = 1850 + CAL_getCH2();
	  if (sentryAutoState == 0) {
		   turretYawVal = CAL_getCH2();
		   setMotorRPM(Bus1, GM6020, 5, (int16_t)(-0.4*(float)(turretYawVal)), test2);
	  } else {
		  if ((sentryAutoState != 0) || (sentryAutoState != 4)) {

			  toGoVelue = 1850 + CAL_getCH2();
			  // 2811
			   // turretYawVal = 1850;
			   // setMotorPosition(Bus1, GM6020, 5, turretYawVal, test3);
		  } else if (sentryAutoState == 4) {
			  toGoVelue = turretRotationForCV[0];
			  // setMotorPosition(Bus1, GM6020, 5, turretRotationForCV[0], test3);
		  }
		  int32_t beans = kP*(toGoVelue - getRotorPosition(Bus1, GM6020, 5)) + kD*(((toGoVelue - getRotorPosition(Bus1, GM6020, 5)) - previousPeans) + -80*gyroVel2);
		  previousPeans = (toGoVelue - getRotorPosition(Bus1, GM6020, 5));

		  int32_t beans2 = applyCtrlLimit(GM6020, beans);
		  CAN_setMotorCtrlVal(Bus1, GM6020, 5, beans2);
  	  }

	  /*
	  turretYawVal = 2243 + CAL_getCH2();
	  setMotorPosition(Bus1, GM6020, 5, turretYawVal, test2);
	 */

	  // Liang's Turret Yaw
	  /*
	  float gyroVel[3] = {IMU_get_gyro(0), IMU_get_gyro(1), IMU_get_gyro(2)};

	  if (((gyroVel[2] > -0.02) && (gyroVel[2] < 0.02))) {
		  gyroVel[2] = 0;
	  }


	  float gVP = gyroVel[2] + (float)(CAL_getCH2()+turretRotationForCV[0])*0.01;
	  gyroidValue += gyroVel[2] + (float)(CAL_getCH2()+turretRotationForCV[0])*0.01;
	  setMotorRPM(Bus1, GM6020, 5, (int16_t)(-1*gyroidValue + -200*gVP), test2);
	  */

	  // UART_Printf(&huart6, "P Term: %f, I Term: %f\r\n", gVP, gyroidValue);
	  // Jan's Turret Yaw
	  /*
	  float targetTurretAngVel = (float)(CAL_getCH2()+turretRotationForCV[0])*0.032;

	  targetTurretAng -= targetTurretAngVel;
	  if(targetTurretAng<0){
		  targetTurretAng = 360.0-targetTurretAng;
	  }else if(targetTurretAng>360.0){
		  targetTurretAng = targetTurretAng-360.0;
	  }

	  //find current angular velocity in degrees/iteration (i think) (iknow now)
	  float currentTurretAngVel = IMU_get_gyro(2)*2.445456578;

	  //find current angle also standard math in degrees
	  if(currentTurretAngVel>0.006||currentTurretAngVel<-0.006){//filter out noise from gyro
		  currentTurretAng = currentTurretAng + currentTurretAngVel; //proportional to ang position, not
		  if(currentTurretAng<0.0){
			  currentTurretAng = 360.0-currentTurretAng;
		  }else if(currentTurretAng>360.0){
			  currentTurretAng = currentTurretAng-360.0;
		  }
	  }
	  //-115
	  setMotorRPM(Bus1,GM6020,5,(-90.0*(currentTurretAngVel+0.9*targetTurretAngVel)+10.0*angSmallestDiff(targetTurretAng, currentTurretAng)), turretRotation);
	  UART_Printf(&huart6, "CurrentVel=%f,TargetAngleVel=%f,TargetPosition=%f,CurrentPosition=%f\r\n", currentTurretAngVel, targetTurretAngVel+175, targetTurretAng, currentTurretAng);
	  */
	  // UART_Printf(&huart1, "BUFFER!!!: %d\r\n", CAL_getBufferEnergy());
	  // UART_Printf(&huart6, "Gyro: %f,    currentTurretAng: %f,    currentTurretAngVel: %f,    targetTurretAng: %f,    angSmallestDiff: %f,    calRPM_PID: %d,    getMotorPosition: %d\r\n", IMU_get_gyro(2), currentTurretAng, currentTurretAngVel, targetTurretAng, angSmallestDiff(targetTurretAng, currentTurretAng), calcRPM_PID(Bus1, GM6020, 5, (-80*(currentTurretAngVel+1.1*targetTurretAngVel)+50.0*angSmallestDiff(targetTurretAng, currentTurretAng)), turretRotation), getRotorPosition(Bus1, GM6020, 5));


	  // UART_Printf(&huart1, "M1: %d | M2: %d | M3: %d | M4: %d\r\n", getMotorRPM(Bus1, M3508, 1), getMotorRPM(Bus1, M3508, 2), getMotorRPM(Bus1, M3508, 3), getMotorRPM(Bus1, M3508, 4));

	  // Shooting Settings
      if (CAL_getS1() > 1 || SENTRYSHOOT[1] == 1) {
          setMotorRPM(Bus1, M3508, 1, -1*speed, flywheels);

          setMotorRPM(Bus1, M3508, 2, speed, flywheels);
          // osDelay(2);
          setMotorRPM(Bus1, M3508, 3, speed, flywheels);
          // osDelay(2);
          setMotorRPM(Bus1, M3508, 4, -1*speed, flywheels);
          // osDelay(2);
          // setMotorRPM(Bus1, M3508, 1, -1*speed, flywheels);
          // usart_printf("Shooting\r\n");
          // usart_printf("On\r\n");
      } else {
      	// setMotorRPM(Bus1, M3508, 1, 0, yawPresetVoltageRPM);
      	setMotorRPM(Bus1, M3508, 2, 0, flywheels);
      	// osDelay(2);
      	setMotorRPM(Bus1, M3508, 3, 0, flywheels);
      	// osDelay(2);
      	setMotorRPM(Bus1, M3508, 4, 0, flywheels);
      	// osDelay(2);
      	setMotorRPM(Bus1, M3508, 1, 0, flywheels);
      	// usart_printf("Off\r\n");
      }


      float heatBufferFraction1 = 0;
      float heatBufferFraction2 = 0;
      if (CAL_getHeatLimit() != 0) {
    	  heatBufferFraction1 = (float)(CAL_getBarrel1Heat())/(float)(CAL_getHeatLimit());
    	  heatBufferFraction2 = (float)(CAL_getBarrel2Heat())/(float)(CAL_getHeatLimit());
      }

      uint8_t flywheelReved = 0;
      if ((getMotorRPM(Bus1, M3508, 1) < -4500) && (getMotorRPM(Bus1, M3508, 2) > 4500) && (getMotorRPM(Bus1, M3508, 3) > 4500) && (getMotorRPM(Bus1, M3508, 4) < -4500)) {
    	  flywheelReved = 1;
      } else {
    	  flywheelReved = 0;
      }

	  if (CAL_getS1() == 2) {
		  // Motors 2 & 4 (Left)
		  fondlerAutoReverse (fondlerVars[0], 1, 5, -1, fondler);
		  osDelay(2);
		  // Motors 1 & 3 (Right)
	      fondlerAutoReverse (fondlerVars[1], 1, 6, 1, fondler);
		  /*
			setMotorRPM(Bus1, M2006, 5, 5000, fondler);
			osDelay(2);
			setMotorRPM(Bus1, M2006, 6, -5000, fondler);
			*/

	  } else if ((( SENTRYSHOOT[1] == 1) && flywheelReved == 1 && (heatBufferFraction1 < 0.8 && heatBufferFraction2 < 0.8))) {
		  if (getMotorRPM(Bus1, M3508, 2) < 4800 && getMotorRPM(Bus1, M3508, 4) > -4800 && barrelToggle == 1) {
			  barrelToggle = 0;
		  } else if (getMotorRPM(Bus1, M3508, 3) < 4800 && getMotorRPM(Bus1, M3508, 1) > -4800 && barrelToggle == 0) {
			  barrelToggle = 1;
		  }

		  if (barrelToggle == 0) {
			  fondlerAutoReverse (fondlerVars[1], 1, 6, 1, fondler);
			  osDelay(2);
			  fondlerAutoReverse (fondlerVars[0], 0, 5, -1, fondler);
		  } else if (barrelToggle == 1) {
			  fondlerAutoReverse (fondlerVars[0], 1, 5, -1, fondler);
			  osDelay(2);
			  fondlerAutoReverse (fondlerVars[1], 0, 6, 1, fondler);
		  }
		  // UART_Printf(&huart1, "%d\r\n", barrelToggle);
	  } else {
		  fondlerAutoReverse (fondlerVars[0], 0, 5, -1, fondler);
		  osDelay(2);
		  fondlerAutoReverse (fondlerVars[1], 0, 6, 1, fondler);
		  /*
			setMotorRPM(Bus1, M3508, 5, 0, fondler);
			osDelay(2);
			setMotorRPM(Bus1, M2006, 6, 0, fondler);
		   */
	  }

	  osDelay(5);
  }
  /* USER CODE END StartTurretTask */
}

/* USER CODE BEGIN Header_StartSentryAutonomy */

extern uint16_t CAL_LastTargetX;
extern uint16_t CAL_LastTargetY;
extern uint16_t CAL_LastTargetWidth;
extern uint16_t CAL_LastTargetHeight;

/**
* @brief Function implementing the SentryAutonomy thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartSentryAutonomy */
void StartSentryAutonomy(void *argument)
{
  /* USER CODE BEGIN StartSentryAutonomy */
	osDelay(1000);
	MX_USART1_UART_Init();
	UART_Ex_Init(&huart1);

	int16_t stateCounter = 0;

	int16_t tempTurretRot[2] = {0, 0};

	int16_t oldSequenceNumber = 0;
	int16_t CVArray[5] = {0, 0, 0, 0, 0};
	int16_t enemyRelativeCoords[4][3] = {0};
	float currentTurretAngleSentry = 0;

	CAL_getCurrentStage();
  /* Infinite loop */
  for(;;)
  {
	  /*
		if (game_status.game_progress == 0 && currentGameStatus < 0) {
			currentGameStatus = 0;
		} else if ((game_status.game_progress == 1 && currentGameStatus < 1) || leftSwitch == 2) {
			currentGameStatus = 1;
		} else if (game_status.game_progress == 2 && currentGameStatus < 2) {
			currentGameStatus = 2;
		} else if (game_status.game_progress == 3 && currentGameStatus < 3) {
			currentGameStatus = 3;
		} else if ((game_status.game_progress == 4 && currentGameStatus < 4) || leftSwitch == 3) {
			currentGameStatus = 4;
		} else if ((game_status.game_progress == 5 && currentGameStatus < 5) || leftSwitch == 1) {
			currentGameStatus = 5;
		}
		*/
	  if (getDR16_S2() == 1) {
		  currentGameStatus = 0;
	  } else if (getDR16_S2() == 3) {
		  currentGameStatus = 1;
	  } else if (getDR16_S2() == 2) {
		  currentGameStatus = 4;
	  } else {
		  currentGameStatus = CAL_getCurrentStage();
	  }

	  CAN_Print(turretRotationForCV[0],turretRotationForCV[1],SentryTurnAngle,currentGameStatus,sentryAutoState);
	  // UART_Printf(&huart1, "Current Game Status: %d, Actual Game State: %d, Sentry Auto State: %d, Sentry Turn Angle: %d\r\n", currentGameStatus, CAL_getCurrentStage(), sentryAutoState, SentryTurnAngle);

	  // UART_Printf(&huart1, "Current Game State: %d, Team Colour: %d\r\n", CAL_getCurrentStage(), CAL_getRobotId());


	  switch (currentGameStatus) {
	  case 0: { // Pre Competition
		  /*
		  if ((currentGameStatus < 1 && CAL_getCurrentStage() >= 0)) {
			  currentGameStatus = 1;
		  }
		  */
		  stateCounter = 0;
		  sentryAutoState = 0;
		  break;
	  }
	  case 1: { // Set up Period
		  /*
		  if ((currentGameStatus < 2 && CAL_getCurrentStage() >= 1)) {
			  currentGameStatus = 2;
		  }
		  */
		  SentryTurnAngle = getRotorPosition(Bus1, GM6020, 5);
		  stateCounter = 0;
		  sentryAutoState = 0;
		  break;
	  }
	  case 2: { // 15 Second Referee System Initialization Period
		  /*
		  if ((currentGameStatus < 3 && CAL_getCurrentStage() >= 2)) {
			  currentGameStatus = 3;
		  }
		  */
		  stateCounter = 0;
		  sentryAutoState = 0;
		  break;
	  }
	  case 3: { // 5 Second Countdown
		  /*
		  if ((currentGameStatus < 4 && CAL_getCurrentStage() >= 3)) {
			  currentGameStatus = 4;
		  }
		  */
		  stateCounter = 0;
		  sentryAutoState = 0;
		  break;
	  }
	  case 4: { // In Competition
		  /*
		  if ((currentGameStatus < 5 && CAL_getCurrentStage() >= 4)) {
			  currentGameStatus = 5;
		  }
		  */
		  if (stateCounter < 2000) {
			  stateCounter++;
		  }




		  switch (sentryAutoState) {


		  // DEBUG STATE/Calibrate TurretState
		  case 0: {
			  driveChassisForwards = 0;
			  if (stateCounter > 100) {
				  sentryAutoState = 5;
			  }
			  SentryTurnAngle = getRotorPosition(Bus1, GM6020, 5);
			  SENTRYSHOOT[1] = 0;
			  break;
		  }
		  // AIM INTO REGION STATE
		  case 5: {
			  if (stateCounter > 200) {
				  sentryAutoState = 1;
			  }
			  SENTRYSHOOT[1] = 0;
			  break;
		  }
		  // MOVE INTO WALL STATE
		  case 1: {

			  driveChassisForwards = 1;
			  if (stateCounter > 600) {
				  sentryAutoState = 2;
			  }
			  if (CVArray[4] < 5) {
				  sentryAutoState = 4;
			  }
			  SENTRYSHOOT[1] = 0;
			  break;
		  }
		  // DRYFIRESTATE & SCAN CHECKING STATE
		  case 2:  {
			  driveChassisForwards = 0;
			  if (CVArray[4] < 5) {
				  sentryAutoState = 4;
			  }
			  if (stateCounter > 1000) {
				  sentryAutoState = 3;
			  }
			  SENTRYSHOOT[1] = 1;
			  break;
		  }
		  // SCAN PHASE
		  case 3: {
			  if (CVArray[4] < 5) {
				  sentryAutoState = 4;
			  }
			  SENTRYSHOOT[1] = 0;
			  break;
		  }
		  // FIRE PHASE
		  case 4: {
			  driveChassisForwards = 0;

			  if (CVArray[4] >= 75) {
				  sentryAutoState = 3;
			  }
			  if (CVArray[4] < 75) {
				  // Seeing Someone
				  turretRotationForCV[2] = 1;

				  // Delta Value Thing
				  tempTurretRot[0] = (float)(CVArray[0]) + ((float)(getRotorPosition(Bus1, GM6020, 5))*1.0);
				  tempTurretRot[1] = (float)(CVArray[1]) + ((float)(getRotorPosition(Bus1, GM6020, 5))*1.0);
				  for (uint8_t j = 0; j < 2; j++) {
					  turretRotationForCV[j] = tempTurretRot[j];
				  }

				  if ((WithinRangeCalculator(CVArray[0], 0, 150) == 1) && (WithinRangeCalculator(CVArray[1], 0, 60) == 1) && (CVArray[2] != 0) && (CVArray[3] != 0)) {
					  SENTRYSHOOT[1] = 1;
				  } else {
					  SENTRYSHOOT[1] = 0;
				  }
			  } else {
				  // Not Seeing Someone
				  turretRotationForCV[0] = 0;
				  turretRotationForCV[1] = 0;
				  turretRotationForCV[2] = 0;
				  SENTRYSHOOT[1] = 0;
			  }
			  break;
		  }
		  }




		  if (oldSequenceNumber == CAL_getCVSeq() && CVArray[4] < 75) {
			  CVArray[4] += 1;
		  } else if (oldSequenceNumber == CAL_getCVSeq() && CVArray[4] >= 75) {
			  CVArray[4] = 75;
		  } else {
			  CVArray[0] = CAL_getTargetX();
			  CVArray[1] = CAL_getTargetY();
			  CVArray[2] = CAL_getTargetWidth();
			  CVArray[3] = CAL_getTargetHeight();
			  CVArray[4] = 0;
			  AngletoCoordinateCalculator(CVArray, currentTurretAngleSentry, getRotorPosition(Bus2, GM6020, 3), enemyRelativeCoords);
		  }
		  oldSequenceNumber = CAL_getCVSeq();


		  /*
		  if (CVArray[4] < 75) {
			  // Seeing Someone
			  turretRotationForCV[2] = 1;

			  // Delta Value Thing
			  tempTurretRot[0] = (float)(CVArray[0]) + ((float)(getMotorPosition())*1.0);
			  tempTurretRot[1] = (float)(CVArray[1]) + ((float)(getMotorPosition())*1.0);
			  for (uint8_t j = 0; j < 2; j++) {
				  turretRotationForCV[j] = tempTurretRot[j];
			  }

			  if ((WithinRangeCalculator(CVArray[0], 0, 150) == 1) && (WithinRangeCalculator(CVArray[1], 0, 40) == 1) && (CVArray[2] != 0) && (CVArray[3] != 0)) {
				  SENTRYSHOOT[1] = 1;
			  } else {
				  SENTRYSHOOT[1] = 0;
			  }
		  } else {
			  // Not Seeing Someone
			  turretRotationForCV[0] = 0;
			  turretRotationForCV[1] = 0;
			  turretRotationForCV[2] = 0;
			  SENTRYSHOOT[1] = 0;
		  }
			*/


		  //  UART_Printf(&huart1, "x: %d | y: %d || width s: %d | height: %d || Timeout Length: %d\r\n", CVArray[0], CVArray[1], CVArray[2], CVArray[3], CVArray[4]);
		  // UART_Printf(&huart6, "x: %d\r\n", CAL_getTargetX());
		  // UART_Printf(&huart6, "x: %d | y: %d || width: %d | height: %d | TimeoutLength: %d  | SEQ: %d || Rough Distance: %f\r\n", CVArray[0], CVArray[1], CVArray[2], CVArray[3], CVArray[4], CAL_getCVSeq(), distanceCalc(CVArray[3]));
		  // UART_Printf(&huart6, "CurrentGameStatus: %d\r\n", currentGameStatus);
		  // UART_Printf(&huart1, "x: %d, y: %d\r\n", CVArray[0], CVArray[1]);
		  break;
	  }
	  case 5: { // Competition Results Computation
		  break;
	  }
	  }

	  PWMTimerStarter();
    osDelay(5);

  }

  /* USER CODE END StartSentryAutonomy */
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
